{"version":3,"sources":["ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getStyleComputedProperty.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getParentNode.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getScrollParent.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/isBrowser.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/isIE.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getOffsetParent.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getRoot.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/findCommonOffsetParent.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/isOffsetContainer.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getBordersSize.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getWindowSizes.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getScroll.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getClientRect.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getBoundingClientRect.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getOffsetRectRelativeToArbitraryNode.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/includeScroll.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getFixedPositionOffsetParent.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getBoundaries.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getViewportOffsetRectRelativeToArtbitraryNode.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/isFixed.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/computeAutoPlacement.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getOuterSizes.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getReferenceOffsets.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getTargetOffsets.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getOppositePlacement.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/isModifierEnabled.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/setStyles.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/isNumeric.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/modifiers/arrow.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/modifiers/flip.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getOppositeVariation.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/modifiers/preventOverflow.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/modifiers/shift.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/ng-positioning.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/modifiers/initData.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/getOffsets.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/utils/updateContainerClass.ts","ng://@bit/valor-software.ngx-bootstrap.internal.positioning/positioning/positioning.service.ts"],"names":["getStyleComputedProperty","element","property","nodeType","css","ownerDocument","defaultView","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","_a","overflow","overflowX","overflowY","test","String","isBrowser","window","isIE11","MSInputMethodContext","documentMode","isIE10","userAgent","isIE","version","getOffsetParent","documentElement","sibling","noOffsetParent","offsetParent","nextElementSibling","indexOf","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","firstElementChild","element1root","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","__assign","right","left","bottom","top","getBoundingClientRect","rect","scrollTop","scrollLeft","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","subtract","modifier","includeScroll","getFixedPositionOffsetParent","parentElement","el","getBoundaries","target","padding","boundariesElement","boundaries","excludeScroll","relativeOffset","innerWidth","innerHeight","Number","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","isFixed","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","Object","keys","map","key","__assign$1","area","sort","a","b","filteredAreas","filter","computedPlacement","position","some","allowedPosition","length","variation","split","className","replace","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","hash","matched","getOppositePlacement","isModifierEnabled","options","modifierName","modifiers","enabled","setStyles","renderer","forEach","prop","n","unit","isNaN","isFinite","setStyle","style","arrow","data","arrowElement","instance","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","targetMarginSide","targetBorderSide","sideValue","min","round","flip","__assign$2","adaptivePosition","flipOrder","step","index","overlapsRef","floor","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","getOppositeVariation","preventOverflow","targetStyles","transform","check","primary","value","secondary","__assign$3","shift","basePlacement","shiftvariation","_c","shiftOffsets","_b","__assign$4","Positioning","prototype","hostElement","targetElement","this","offset","positionElements","appendToBody","reduce","modifiedData","hostElPosition","match","placementAuto","positionFixed","undefined","initData","positionService","getOffsets","will-change","containerClass","setAttribute","updateContainerClass","PositioningService","rendererFactory","platformId","_this","update$$","Subject","Map","isDisabled","isPlatformBrowser","triggerEvent$","merge","fromEvent","of","animationFrameScheduler","subscribe","positionElement","_getHtmlElement","attachment","createRenderer","addPositionElement","defineProperty","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","Injectable","RendererFactory2","Inject","args","PLATFORM_ID","ElementRef","nativeElement"],"mappings":"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","sourcesContent":["/**\n * Get CSS computed property of the given element\n */\nexport function getStyleComputedProperty(element: HTMLElement, property?: string): any {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element, null);\n\n  return property ? css[property as any] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n */\nexport function getParentNode(element: any): any {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n","/**\n * Returns the scrolling parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function getScrollParent(element: any): any {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n    default:\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","export const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n","/**\n * Determines if the browser is Internet Explorer\n */\nimport { isBrowser } from './isBrowser';\n\nconst isIE11 = isBrowser && !!((window as any).MSInputMethodContext && (document as any).documentMode);\nconst isIE10 = isBrowser && !!((window as any).MSInputMethodContext && /MSIE 10/.test((navigator as any).userAgent));\n\nexport function isIE(version?: number) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n","/**\n * Returns the offset parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getOffsetParent(element: any): any {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent = element.offsetParent || null;\n\n  // Skip hidden elements which don't have an offsetParent\n  let sibling: HTMLElement | null;\n\n  while (offsetParent === noOffsetParent\n         && element.nextElementSibling\n         && sibling !== element.nextElementSibling) {\n\n      sibling = element.nextElementSibling;\n      offsetParent = sibling.offsetParent;\n    }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  if (\n    ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n","/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nexport function getRoot(node: Node): any {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","/**\n * Finds the offset parent common to the two provided nodes\n */\nimport { isOffsetContainer } from './isOffsetContainer';\nimport { getRoot } from './getRoot';\nimport { getOffsetParent } from './getOffsetParent';\n\nexport function findCommonOffsetParent(element1: HTMLElement, element2: HTMLElement): any {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  /* tslint:disable-next-line: no-bitwise */\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  // Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  ) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","import { getOffsetParent } from './getOffsetParent';\n\nexport function isOffsetContainer(element: any) {\n  const { nodeName } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return (\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n * Helper to detect borders of a given element\n */\n\nexport function getBordersSize(styles: CSSStyleDeclaration, axis: string) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return (\n    parseFloat(styles[`border${sideA}Width` as any]) +\n    parseFloat(styles[`border${sideB}Width` as any])\n  );\n}\n","import { isIE } from './isIE';\n\nfunction getSize(axis: string, body: HTMLElement, html: HTMLElement, computedStyle: CSSStyleDeclaration) {\n  return Math.max(\n    (body as any)[`offset${axis}`],\n    (body as any)[`scroll${axis}`],\n    (html as any)[`client${axis}`],\n    (html as any)[`offset${axis}`],\n    (html as any)[`scroll${axis}`],\n    isIE(10)\n      ? (parseInt((html as any)[`offset${axis}`], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}` as any], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}` as any], 10))\n    : 0\n  );\n}\n\nexport function getWindowSizes(document: Document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n","/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nexport function getScroll(element: HTMLElement, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n */\nimport { Offsets } from '../models';\n\nexport function getClientRect(offsets: Offsets): Offsets {\n  return {\n    ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  };\n}\n","/**\n * Get bounding client rect of given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getBordersSize } from './getBordersSize';\nimport { getWindowSizes } from './getWindowSizes';\nimport { getScroll } from './getScroll';\nimport { getClientRect } from './getClientRect';\nimport { isIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getBoundingClientRect(element: HTMLElement): Offsets {\n  let rect: any = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n\n  const result: any = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  const sizes: any = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  const width =\n    sizes.width || element.clientWidth || result.right - result.left;\n  const height =\n    sizes.height || element.clientHeight || result.bottom - result.top;\n\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n","import { getBoundingClientRect } from './getBoundingClientRect';\nimport { getClientRect } from './getClientRect';\nimport { getScrollParent } from './getScrollParent';\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { includeScroll } from './includeScroll';\nimport { isIE as runIsIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getOffsetRectRelativeToArbitraryNode(\n  children: HTMLElement,\n  parent: HTMLElement,\n  fixedPosition = false\n): Offsets {\n  const isIE10 = runIsIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect: any = getBoundingClientRect(children);\n  const parentRect: any = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n\n  let offsets: Offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10 && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\n  ) {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n","/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function includeScroll(rect: Offsets, element: HTMLElement, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n\n  return rect;\n}\n","/**\n * Finds the first parent of an element that has a transformed property defined\n */\n\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getFixedPositionOffsetParent(element: HTMLElement): HTMLElement {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n   return document.documentElement;\n  }\n\n  let el = element.parentElement;\n\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n","/**\n * Computed the boundaries limits and return them\n */\nimport { getScrollParent } from './getScrollParent';\nimport { getParentNode } from './getParentNode';\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getViewportOffsetRectRelativeToArtbitraryNode } from './getViewportOffsetRectRelativeToArtbitraryNode';\nimport { getWindowSizes } from './getWindowSizes';\nimport { isFixed } from './isFixed';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\n\nexport function getBoundaries(\n  target: HTMLElement,\n  host: HTMLElement,\n  padding = 0,\n  boundariesElement: string,\n  fixedPosition = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries: any = { top: 0, left: 0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(target.ownerDocument);\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n","import { getClientRect } from './getClientRect';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function getViewportOffsetRectRelativeToArtbitraryNode(element: HTMLElement, excludeScroll = false): Offsets {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  const offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width,\n    height\n  };\n\n  return getClientRect(offset);\n}\n","/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function isFixed(element: HTMLElement): boolean {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n","/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nimport { getBoundaries } from './getBoundaries';\nimport { Offsets } from '../models';\n\nfunction getArea({ width, height }: { [key: string]: number }) {\n  return width * height;\n}\n\nexport function computeAutoPlacement(\n  placement: string,\n  refRect: Offsets,\n  target: HTMLElement,\n  host: HTMLElement,\n  allowedPositions: any[] = ['top', 'bottom', 'right', 'left'],\n  boundariesElement = 'viewport',\n  padding = 0\n) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n\n  const rects: any = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  const sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area: getArea(rects[key])\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  let filteredAreas: any[] = sortedAreas.filter(\n    ({ width, height }) => {\n      return width >= target.clientWidth\n        && height >= target.clientHeight;\n    }\n  );\n\n  filteredAreas = filteredAreas.filter((position: any) => {\n    return allowedPositions\n      .some((allowedPosition: string) => {\n        return allowedPosition === position.key;\n      });\n  });\n\n  const computedPlacement: string = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const variation = placement.split(' ')[1];\n\n  // for tooltip on auto position\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${computedPlacement}`);\n\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n */\nexport function getOuterSizes(element: any) {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n","/**\n * Get offsets to the reference element\n */\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\nimport { Offsets } from '../models';\n\nexport function getReferenceOffsets(\n  target: HTMLElement,\n  host: HTMLElement,\n  fixedPosition: boolean = null\n): Offsets {\n  const commonOffsetParent = fixedPosition\n    ? getFixedPositionOffsetParent(target)\n    : findCommonOffsetParent(target, host);\n\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n","/**\n * Get offsets to the target\n */\nimport { getOppositePlacement } from './getOppositePlacement';\nimport { getOuterSizes } from './getOuterSizes';\nimport { Offsets } from '../models';\n\nexport function getTargetOffsets(\n  target: HTMLElement,\n  hostOffsets: Offsets,\n  position: string\n): Offsets {\n  const placement = position.split(' ')[0];\n\n  // Get target node sizes\n  const targetRect = getOuterSizes(target);\n\n  // Add position, width and height to our offsets object\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  };\n\n  // depending by the target placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  (targetOffsets as any)[mainSide] =\n    hostOffsets[mainSide] +\n    hostOffsets[measurement] / 2 -\n    targetRect[measurement] / 2;\n\n  (targetOffsets as any)[secondarySide] = placement === secondarySide\n    ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\n    : (hostOffsets as any)[getOppositePlacement(secondarySide)];\n\n  return targetOffsets;\n}\n","/**\n * Get the opposite placement of the given one\n */\nexport function getOppositePlacement(placement: string) {\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\n  return placement.replace(/left|right|bottom|top/g, matched => (hash as any)[matched]);\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n */\nexport function isModifierEnabled(options: any, modifierName: string) {\n  return options\n    && options.modifiers\n    && options.modifiers[modifierName]\n    && options.modifiers[modifierName].enabled;\n}\n","/**\n * Set the style to the given popper\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { isNumeric } from './isNumeric';\n\nexport function setStyles(element: HTMLElement, styles: any, renderer?: Renderer2) {\n  Object.keys(styles).forEach((prop: any) => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n      isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n\n      return;\n    }\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n","/**\n * Tells if a given input is a number\n */\nexport function isNumeric(n: any) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import { getClientRect, getOuterSizes, getStyleComputedProperty } from '../utils';\nimport { Data } from '../models';\n\nexport function arrow(data: Data) {\n  let targetOffsets = data.offsets.target;\n  // if arrowElement is a string, suppose it's a CSS selector\n  const arrowElement: HTMLElement | null = data.instance.target.querySelector('.arrow');\n\n  // if arrowElement is not found, don't run the modifier\n  if (!arrowElement) {\n    return data;\n  }\n\n  const isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  // top/left side\n  if (data.offsets.host[opSide] - arrowElementSize < (targetOffsets as any)[side]) {\n    (targetOffsets as any)[side] -=\n      (targetOffsets as any)[side] - (data.offsets.host[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (Number((data as any).offsets.host[side]) + Number(arrowElementSize) > (targetOffsets as any)[opSide]) {\n    (targetOffsets as any)[side] +=\n      Number((data as any).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets as any)[opSide]);\n  }\n  targetOffsets = getClientRect(targetOffsets);\n\n  // compute center of the target\n  const center = Number((data as any).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n\n  // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n  const css = getStyleComputedProperty(data.instance.target);\n\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let sideValue =\n    center - (targetOffsets as any)[side] - targetMarginSide - targetBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its target\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  data.instance.arrow = arrowElement;\n\n  return data;\n}\n","import {\n  computeAutoPlacement,\n  getBoundaries,\n  getClientRect,\n  getOppositeVariation,\n  getTargetOffsets,\n  isModifierEnabled\n} from '../utils';\n\nimport { Data } from '../models';\n\nexport function flip(data: Data): Data {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n\n    data.offsets.target = {\n      ...data.offsets.target,\n      ...getTargetOffsets(\n        data.instance.target,\n        data.offsets.host,\n        data.placement\n      )\n    };\n\n    return data;\n  }\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'viewport',\n    false // positionFixed\n  );\n\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n\n  const offsetsHost = data.offsets.host;\n  const target = data.instance.target;\n  const host = data.instance.host;\n\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  const flipOrder = [placement, adaptivePosition];\n\n  /* tslint:disable-next-line: cyclomatic-complexity */\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split(' ')[0];\n\n    // using floor because the host offsets may contain decimals we are not going to consider here\n    const overlapsRef =\n      (placement === 'left' &&\n        Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\n      (placement === 'right' &&\n        Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\n      (placement === 'top' &&\n        Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\n      (placement === 'bottom' &&\n        Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\n\n    const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement === 'left' && overflowsLeft) ||\n      (placement === 'right' && overflowsRight) ||\n      (placement === 'top' && overflowsTop) ||\n      (placement === 'bottom' && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation =\n      ((isVertical && variation === 'left' && overflowsLeft) ||\n        (isVertical && variation === 'right' && overflowsRight) ||\n        (!isVertical && variation === 'left' && overflowsTop) ||\n        (!isVertical && variation === 'right' && overflowsBottom));\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? ` ${variation}` : '');\n\n      data.offsets.target = {\n        ...data.offsets.target,\n        ...getTargetOffsets(\n          data.instance.target,\n          data.offsets.host,\n          data.placement\n        )\n      };\n    }\n  });\n\n  return data;\n}\n","/**\n * Get the opposite placement variation of the given one\n */\nexport function getOppositeVariation(variation: string) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n","import { getBoundaries, isModifierEnabled } from '../utils';\nimport { Data } from '../models';\n\nexport function preventOverflow(data: Data) {\n\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  }\n\n  // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n  const { top, left, [transformProp]: transform } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'scrollParent',\n    false // positionFixed\n  );\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n\n  const order = ['left', 'right', 'top', 'bottom'];\n\n  const check = {\n    primary(placement: string) {\n      let value = (data as any).offsets.target[placement];\n      if (\n        (data as any).offsets.target[placement] < boundaries[placement] &&\n        !false // options.escapeWithReference\n      ) {\n        value = Math.max((data as any).offsets.target[placement], boundaries[placement]);\n      }\n\n      return { [placement]: value };\n    },\n    secondary(placement: string) {\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = data.offsets.target[mainSide];\n      if (\n        (data as any).offsets.target[placement] > boundaries[placement] &&\n        !false // escapeWithReference\n      ) {\n        value = Math.min(\n          data.offsets.target[mainSide],\n          boundaries[placement] -\n          (placement === 'right' ? data.offsets.target.width : data.offsets.target.height)\n        );\n      }\n\n      return { [mainSide]: value };\n    }\n  };\n\n  let side: string;\n\n  order.forEach(placement => {\n    side = ['left', 'top']\n      .indexOf(placement) !== -1\n      ? 'primary'\n      : 'secondary';\n\n    data.offsets.target = {\n      ...data.offsets.target,\n      ...(check as any)[side](placement)\n    };\n\n  });\n\n  return data;\n}\n","import { Data } from '../models';\n\nexport function shift(data: Data): Data {\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftvariation = placement.split(' ')[1];\n\n  if (shiftvariation) {\n    const { host, target } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n\n    const shiftOffsets = {\n      start: { [side]: host[side] },\n      end: {\n        [side]: host[side] + host[measurement] - target[measurement]\n      }\n    };\n\n    data.offsets.target = { ...target, ...(shiftOffsets as any)[shiftvariation] };\n  }\n\n  return data;\n}\n","/**\n * @copyright Valor Software\n * @copyright Federico Zivolo and contributors\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { getOffsets, getReferenceOffsets, updateContainerClass, setStyles } from './utils';\n\nimport { arrow, flip, preventOverflow, shift, initData } from './modifiers';\nimport { Data, Offsets, Options } from './models';\n\n\nexport class Positioning {\n  position(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return this.offset(hostElement, targetElement, false);\n  }\n\n  offset(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n\n  positionElements(\n    hostElement: HTMLElement,\n    targetElement: HTMLElement,\n    position: string,\n    appendToBody?: boolean,\n    options?: Options\n  ): Data {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n\n    return chainOfModifiers.reduce(\n      (modifiedData, modifier) => modifier(modifiedData),\n      initData(targetElement, hostElement, position, options)\n    );\n  }\n}\n\nconst positionService = new Positioning();\n\nexport function positionElements(\n  hostElement: HTMLElement,\n  targetElement: HTMLElement,\n  placement: string,\n  appendToBody?: boolean,\n  options?: Options,\n  renderer?: Renderer2\n): void {\n\n  const data = positionService.positionElements(\n    hostElement,\n    targetElement,\n    placement,\n    appendToBody,\n    options\n  );\n\n  const offsets = getOffsets(data);\n\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n","import {\n  computeAutoPlacement,\n  getReferenceOffsets,\n  getTargetOffsets\n} from '../utils';\n\nimport { Data, Options } from '../models';\n\nexport function initData(\n  targetElement: HTMLElement, hostElement: HTMLElement, position: string, options: Options\n): Data {\n\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/)\n    && !position.match(/^(left|right|top|bottom)*\\s*(start|end)*$/)) {\n      /* tslint:disable-next-line: no-parameter-reassignment */\n      position = 'auto';\n    }\n\n  const placementAuto = !!position.match(/auto/g);\n\n  // support old placements 'auto left|right|top|bottom'\n  let placement = position.match(/auto\\s(left|right|top|bottom)/)\n    ? position.split(' ')[1] || 'auto'\n    : position;\n\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n\n  placement = computeAutoPlacement(\n    placement,\n    hostElPosition,\n    targetElement,\n    hostElement,\n    options ? options.allowedPositions : undefined\n  );\n\n  return {\n    options,\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n","import { Data, Offsets } from '../models';\n\nexport function getOffsets(data: Data): Offsets {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n","/**\n * Update class for the given popper\n */\nimport { Renderer2 } from '@angular/core';\nimport { Data } from '../models';\n\nexport function updateContainerClass(data: Data, renderer?: Renderer2): void {\n  const target = data.instance.target;\n\n  let containerClass = target.className;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n    containerClass = containerClass.replace(/\\sauto/g, ` ${data.placement}`);\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1  && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom/g, `${data.placement.split(' ')[0]}`);\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n\n    return;\n  }\n\n  target.className = containerClass;\n}\n","import { Injectable, ElementRef, RendererFactory2, Inject, PLATFORM_ID } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\nimport { positionElements } from './ng-positioning';\n\nimport { fromEvent, merge, of, animationFrameScheduler, Subject, Observable } from 'rxjs';\nimport { Options } from './models';\n\n\nexport interface PositioningOptions {\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n  element?: HTMLElement | ElementRef | string;\n\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n  target?: HTMLElement | ElementRef | string;\n\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   */\n  attachment?: string;\n\n  /** A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   */\n  targetAttachment?: string;\n\n  /** A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   */\n  offset?: string;\n\n  /** A string similar to `offset`, but referring to the offset of the target */\n  targetOffset?: string;\n\n  /** If true component will be attached to body */\n  appendToBody?: boolean;\n}\n\n\n@Injectable()\nexport class PositioningService {\n  private options: Options;\n  private update$$ = new Subject<null>();\n  private positionElements = new Map();\n  private triggerEvent$: Observable<number|Event>;\n  private isDisabled = false;\n\n  constructor(\n    rendererFactory: RendererFactory2,\n    @Inject(PLATFORM_ID) platformId: number\n  ) {\n    if (isPlatformBrowser(platformId)) {\n      this.triggerEvent$ = merge(\n        fromEvent(window, 'scroll'),\n        fromEvent(window, 'resize'),\n        /* tslint:disable-next-line: deprecation */\n        of(0, animationFrameScheduler),\n        this.update$$\n      );\n\n      this.triggerEvent$.subscribe(() => {\n          if (this.isDisabled) {\n            return;\n          }\n\n          this.positionElements\n            /* tslint:disable-next-line: no-any */\n            .forEach((positionElement: any) => {\n              positionElements(\n                _getHtmlElement(positionElement.target),\n                _getHtmlElement(positionElement.element),\n                positionElement.attachment,\n                positionElement.appendToBody,\n                this.options,\n                rendererFactory.createRenderer(null, null)\n              );\n            });\n        });\n    }\n  }\n\n  position(options: PositioningOptions): void {\n    this.addPositionElement(options);\n  }\n\n  get event$(): Observable<number|Event> {\n    return this.triggerEvent$;\n  }\n\n  disable(): void {\n    this.isDisabled = true;\n  }\n\n  enable(): void {\n    this.isDisabled = false;\n  }\n\n  addPositionElement(options: PositioningOptions): void {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n\n  calcPosition(): void {\n    this.update$$.next();\n  }\n\n  deletePositionElement(elRef: ElementRef): void {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n\n  setOptions(options: Options) {\n    this.options = options;\n  }\n}\n\nfunction _getHtmlElement(element: HTMLElement | ElementRef | string): HTMLElement {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n"]}